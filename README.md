# Overview
UOW: Programming Languages Part B

# Description 

[Part B](https://www.coursera.org/learn/programming-languages-part-b/home/week/1) of the three-part course looks at functional programming through the lens of another language Racket. Through which, we learn more programming concepts and also relate to previous concepts in a very different syntax. 

In part B of the course, download the [DrRacket Programming System](http://racket-lang.org/download) to read the Racket Language. Look at [Racket Guide](https://docs.racket-lang.org/guide/index.html) for more documentation on how to use the Racket language.

Course Goals
---
Successful course participants will:
- Internalize an accurate understanding of what functional and object-oriented programs mean
- Develop the skills necessary to learn new programming languages quickly
- Master specific language concepts such that they can recognize them in strange guises
- Learn to evaluate the power and elegance of programming languages and their constructs
- Attain reasonable proficiency in the ML, Racket, and Ruby languages --- and, as a by-product, become more proficient in languages they already know

## Recommended Background
The course assumes students are familiar with programming covered by most introductory courses, but it is explicitly designed not to be a particularly advanced course. Students should be comfortable with variables, conditionals, arrays, linked lists, stacks, and recursion (though recursion will be reviewed and expanded upon), and the difference between an interface and an implementation. Students should be eager to write programs in languages new to them. Part C of the course analyzes basic object-oriented concepts and contrasts them with those of other languages, so familiarity with Java or a closely related language (e.g., C#) may be helpful, but it is not necessary for the Part C assignments.

This course is based on a course designed for second- and third-year undergraduates: not a first computer science course, but not an advanced course either. So it certainly will not cover everything in the beautiful world of programming languages, but it is a solid introduction.

If you approach the course by saying, "I will have fun learning to think in new ways," then you will do well. If you instead say, "I will try to fit everything I see into the way I already look at programming," then you may get frustrated. By the end, the course material will relate back to what you know, but be patient.

Approach the homework by thinking about how it relates to the lecture material. The programs you will write are often a bit more sophisticated than those in the lectures, but you should be using the same concepts. Especially in the early assignments, you will not need to come up with a large number of tricks or learn much beyond what is in the lectures.

For the exams, focus more on the concepts than just how to write programs. The exam questions will have some of each kind of question, but the more conceptual questions are covered less by the homeworks so you need to do more to study for them.

Treat the peer assessments as a great opportunity to learn by reading other people's code: both to find good examples and to learn what might make your own code difficult for other people to understand. We truly believe peer assessment is more than just a scalable way to grade program style: it will help you learn.

## Syllabus
Part A:
---
- Syntax vs. semantics vs. idioms vs. libraries vs. tools
- ML basics (bindings, conditionals, records, functions)
- Recursive functions and recursive types
- Benefits of no mutation
- Algebraic datatypes, pattern matching
- Tail recursion
- Higher-order functions; closures
- Lexical scope
- Currying
- Syntactic sugar
- Equivalence and effects
- Parametric polymorphism and container types
- Type inference
- Abstract types and modules

Part B:
---
- Racket basics
- Dynamic vs. static typing
- Laziness, streams, and memoization
- Implementing languages, especially higher-order functions
- Macros
- Eval

Part C:
---
- Ruby basics
- Object-oriented programming is dynamic dispatch
- Pure object-orientation
- Implementing dynamic dispatch
- Multiple inheritance, interfaces, and mixins
- OOP vs. functional decomposition and extensibility
- Subtyping for records, functions, and objects
- Class-based subtyping
- Subtyping
- Subtyping vs. parametric polymorphism; bounded polymorphism
